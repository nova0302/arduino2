#+TITLE: Arduino 
#+HTML_HEAD_EXTRA: <style>pre {font-family: "Times New Roman"; font-size: 130%;}</style>
#+STYLE: <style type="text/css">
#+STYLE:<!--/*--><![CDATA[/*><!--*/
#+STYLE: div.figure { float:left; }
#+STYLE: /*]]>*/-->
#+STYLE: </style>
#+OPTIONS: ^:nil

* Arduino Intro
** Entry Level
   [[./images/entry_level.jpg]]

** Enhanced Features
   [[./images/enhanced_features.jpg]]

** Arduino Products
   [[./images/arduino_products.jpg]]

** Arduino MEGA 2560
#+CAPTION: Arduino MEGA 2560
#+ATTR_HTML: :alt cat/spider image :title Action! :align center :width 800 :hight 600
   [[./images/arduino_mega_2560.jpg]]

** Technical specs
#+CAPTION: Technical specs
#+ATTR_HTML: :align center:width 800 :hight 600
   [[./images/technical_specs.jpg]]
   
** Training Kit
#+CAPTION: Training Kit
#+ATTR_HTML: :alt cat/spider image :title Action! :align center :width 800 :hight 600
   [[./images/training_kit.jpg]]

** Arduino
#+CAPTION: Training Kit
#+ATTR_HTML: :width 800 :hight 600
   [[./images/arduino_mega2560_adk.jpg]]
   

* C & C++ Intro
** Launge Reference
#+ATTR_HTML: :width 800 :hight 600
   [[./images/languageReference_01.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/languageReference_02.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/languageReference_03.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/languageReference_04.jpg]]

*** Structure
**** Constrol Structures
***** if
***** if...else
***** for
***** switch case
***** while
***** do...while
***** break
***** continue
***** return
***** goto

**** Further Syntax
***** ;, {}, //, /**/
***** #define
***** #include

**** Arithmetic Operators
***** =, +, -, *, /, %
     
#+NAME: operators 
#+BEGIN_SRC C -n :results output
  #include <stdio.h>
  int main(int argc, char *argv[]) {
    int num = 8;
    int den = 3;
    printf("%d / %d = %d\n", num, den, num / den);
    printf("%d %% %d = %d\n",num, den, num % den);
    return 0;
  }
#+END_SRC

#+RESULTS: 
: 8 / 3 = 2
: 8 % 3 = 2

**** Comparison Operators
***** ==, !=, <, >, <= >=

**** Boolean Operators
***** &&, ||, !

**** Pointer Access Operators
***** *
***** &

**** Bitwise Operators
***** &, |, ^, ~, <<, >>

**** Compound Operators
***** ++, --, +=, -=, *=, /=, %=, &=, !=
      
*** Variables
**** Constants
***** HIGH | LOW
***** INPUT | OUTPUT | INPUT_PULLUP
***** LED_BUILTIN
***** true | false
***** integer constants
***** floating point constants

**** Data Types
***** void, boolean, char, unsigned char, byte, int, unsigned int, word, long,...
***** string, String
***** array

**** Conversion
***** char(), byte(), ...

**** variable scope
***** static
***** volatile
***** const
***** Utilities
***** sizeof()

*** Functions
**** Digital I/O
***** pinMode()
****** Description
       - Configures the specified pin to behave either as an input or an output.
       - As of Arduino 1.0.1, it is possible to enable the internal pullup resistors with the mode INPUT_PULLUP.
       - Additionally, the INPUT mode explicitly disables the internal pullups.
****** Syntax
       - pinMode(pin, mode)
****** Parameters
       - pin: the number of the pin whose mode you wish to set
       - mode: INPUT, OUTPUT, INPUT_PULLUP
****** Example
#+BEGIN_SRC C -n
const char ledPin = 13;                 // LED connected to digital pin 13

void setup() {
  pinMode(ledPin, OUTPUT);      // sets the digital pin as output
}

void loop() {
  digitalWrite(ledPin, HIGH);   // sets the LED on
  delay(1000);                  // waits for a second
  digitalWrite(ledPin, LOW);    // sets the LED off
  delay(1000);                  // waits for a second
}
#+END_SRC
***** digitalWrite()
****** Description
       - Write a HIGH or A LOW value to a digital pin.
       - It is recommended to set the pinMode() to INPUT_PULLUP to enable the internal pull-up resistor.
       - Note. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor,
       - which acts like a large current-limiting resistor.
****** Syntax
       digitalWrite(pin, value)
****** Parameters
       1. pin: the pin number
       2. value: HIGH or LOW
****** Note 
       1. The analog input pins can be used as a digital pins, referred to as A0, A1, etc.
***** digitalRead()
****** Description
       1. Reads the value from a specified digital pin, either HIGH or LOW.
****** Syntax
       digitalRead(pin)
****** Example
#+BEGIN_SRC C -n
const char ledPin = 13; // LED connected to digital pin 13
const char btnPin = 7;   // pushbutton connected to digital pin 7

int val = 0;     // variable to store the read value

void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the digital pin 13 as output
  pinMode(btnPin, INPUT);      // sets the digital pin 7 as input
}

void loop()
{
  val = digitalRead(btnPin);   // read the input pin
  digitalWrite(ledPin, val);    // sets the LED to the button's value
}
#+END_SRC
****** Note
       1. The analog input pins can be used as a digital pins, referred to as A0, A1, etc.

**** Analog I/O
***** analogWrite()
****** Description
       1. The frequency of the PWM signal on most pins is approximately _490Hz_.
       2. on Arduino Mega, it works on _pins 2-13 and 44-46_.
       3. _You don't need to call pinMode()_ to set the pin as an output before calling analogWrite()
****** Syntax
       analogWrite(pin, value)
****** Parameters
       1. pin -  the pin to write to.
       2. value - the duty cycle: _between 0(always off) and 255(always on)_.
       3.
****** Notes and Known Issues
       1. The PWM outputs generated on _pins 5 and 6_ will have higher-than-expected duty cycles.
****** Example
#+BEGIN_SRC c -n
  int analogPin = 0;     // potentiometer wiper (middle terminal) connected to analog pin 3
                         // outside leads to ground and +5V

  int potVal = 0;           // variable to store the potValue read

  void setup() {
    Serial.begin(9600);    //  setup serial
    //pinMode(13, OUTPUT); // no need for analogWrite
    //pinMode(2, OUTPUT);
  }

  void loop() {
    potVal = analogRead(analogPin);    // read the input pin
    potVal = potVal >> 2; //potVal/4 = 0,1023 -> 0,255
    Serial.println(potVal);            // debug potValue
    analogWrite(13, potVal);
    analogWrite( 2, potVal);
  }
#+END_SRC

***** analogRead()
****** Description
       1. Read the value from the specified analog pin.
       2. _16 channels_ on Mega, _10-bit analog to digital converter_.
       3. Input voltages between _0 and 5 volts_ into integer values between _0 and 1023._
       4. 5 volts / 1024 units, or _4.9 mV per unit_.
       5. The input range and resolution can be changed using _analogReference()_.
       6. It takes about 100 microseconds(0.0001s) to read an analog input, _10,000 times a second_.
****** Syntex
       analogRead(pin)
****** Parameters
       1. pin: the number of analog input pin to read from (_0 to 15 on Mega_)
****** Return 
       1. int(_0 to 1023_)
****** Note
       1. If the analog input pin is not connected to anything, the value returned by analogRead() will
       2. _fluctuate_ based on a munber of factors(e.g. the values of the other analog inputs,
       3. how close your hand is to the board, tec.).
**** interrupts

***** attachInterrupt()<<target>>
****** Description
    1. use _digitalPinToInterrupt(3)_ as _the first parameter_ to *attachInterrupt*.
|-----------------------------------+------------------------------------|
| Board                             | Digital pins usable for interrupts |
|-----------------------------------+------------------------------------|
| Uno, Nano, Mini, other 328-based  | 2, 3                               |
| _Mega, Mega2560, MegaADK_         | 2, 3, 18, 19, 20, 21               |
| Micro, Leonardo, other 32u4-based | 0, 1, 2, 3, 7                      |
| Zero                              | all digital pins, except 4         |
| MKR1000 Rev.1                     | 0, 1, 4, 5, 6, 7, 8, 9, A1, A2     |
| Due                               | all digital pins                   |
| 101                               | all digital pins                   |
|-----------------------------------+------------------------------------|
****** Note
       1. Inside the attached function, _delay()_ won't work,
       2. and the value returned by mills() will _not increment_.
       3. Serial data received while in the function may be lost.
       4. You should declare as _volatile_ any variables that you modify _within the_
       5. _attached function_. See the sectionon ISRs below for more information.
****** About interrupt Service Routines
       1. ISRs have _no parameters_, and they _shouldn't return_ anything.
       2. should be as short as possible.
       3. To make sure variables shared between an ISR and the main program are updated correctly,
       4. delcare them as _volatile_.
****** Syntax
       1. attachInterrupt(digitalpintointerrupt(pin), ISR, mode) (recommended)
          
****** Parameters
       1. pin: the pin number
       2. ISR: the ISR to call when the interrupt occurs;
       3. mode: defines when the interrupt should be triggered.
       4. (*LOW*, *HIGH*, *CHANGE*, *RISING*, *FALLING*)
****** Returns
       none
****** Example
#+BEGIN_SRC C -n
const byte ledPin = 13;
const byte interruptPin = 2;
const byte colPin1 = 23;
/*** should be volatile ***/
volatile byte state = LOW;

void setup() {
  // put your setup code here, to run once:
pinMode(ledPin, OUTPUT);

pinMode(colPin1, OUTPUT);
digitalWrite(colPin1, LOW);

pinMode(interruptPin, INPUT);
attachInterrupt(digitalPinToInterrupt(interruptPin), blink, RISING);
}

void loop() {
digitalWrite(ledPin, state);
  noInterrupts();
  // critical, time-sensitive code here
  interrupts();
  // other code here
}

void blink(){
  state = !state;
}
#+END_SRC
***** detachInterrupt()
****** Description
       - Turns off the given interrupt.

****** Syntax
       - detachinterrupt(digitalPinToInterrupt(pin));

****** Parameters
       - pin: the pin number of the interrupt to disable

***** Timer Interrupt
***** Time
***** millis()
***** micros()
***** delay()

**** Math
*** usefull functions
**** map(value, 0, 1023, 0, 100);

** C++ intro
*** C++ 특징 
    - [[http://jstar.tistory.com/entry/C%EC%9D%98-%ED%8A%B9%EC%A7%95][c++의 특징에 관한 정리]]
**** 캡슐화(Encapsulation )- the hiding of information
     - private
     - public
     - protected
**** 상속(Inheritance)
     - allows one data type to aquire properties fo other data types
**** 연산자 오버로딩(Operators and operator overloading)
**** 다형성(Polymorphism)
     - enables one common interface for many implementations,
     - and for objects to act differently under different circumstances.
***** 정적 다형성(static polymorphism )
      - allows programs to declare multiple functions having the same name but with different arguments
***** 동적 다형성(dynamic polymorphism)
      - Variable pointers and references to a base class type in C++
      - can also refer to objects of any derived classes of that type.

*** Class
#+NAME: member_initialization
#+BEGIN_SRC C++ -n :results output 
#include <iostream>
using namespace std;
#define PI 3.14159
class Circle{
private:                        
  double radius;                //멤버변수 
public:
  Circle(double r) { //생성자
    radius = r; 
  } 
  double area(){ //멤버함수 
    return radius * radius * PI;
  }
};
class Cylinder : public Circle{ //상속 
private:
  double height;
public:
  Cylinder(double r, double h) 
    :Circle(r){
    height = h;
  }
  double volume(){
    return area() * height;
  }
};

int main(int argc, char *argv[]){

  Cylinder cyl(10,20);
  Circle cir(5);
  cout << "cyl's volume: " << cyl.volume() << endl;
  cout << "cir's area: " << cir.area() << endl;
  return 0;
}
#+END_SRC

#+RESULTS: member_initialization

#+RESULTS: 
: cyl's volume: 6283.19
: cir's area: 78.5398
*** pointer
#+NAME: pointer
#+BEGIN_SRC C -n :results output 
#include <stdio.h>

void exchange (int* a, int* b);

int main(int argc, char *argv[]) {

  int a=3, b=5;
  printf("a=%d, b=%d\n", a,b);

  exchange (&a, &b);

  printf("a=%d, b=%d\n", a,b);

  return 0;
}

void exchange (int* a, int* b){
  int temp = *a;
  *a = *b;
  *b = temp;
}

#+END_SRC

#+RESULTS: 
: a=3, b=5
: a=5, b=3


* Arduino Programming
** 실 습 순 서 
*** 트래이닝킷의 전원이 꺼진 상태에서 캐이블 연결: 아두이노 <-> 아두이노 쉴드
#+ATTR_HTML: :width 800 :hight 600
   [[./images/led13.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/led.jpg]]

*** 프로그램 코딩 디버깅(Ctrl - R)
#+BEGIN_SRC C -n
const char ledPin = 13;         // LED connected to digital pin 13

void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the digital pin as output
}

void loop()
{
  digitalWrite(ledPin, HIGH);   // LED on
  delay(1000);                  // waits for a second
  digitalWrite(ledPin, LOW);    // LED off
  delay(1000);                  // waits for a second
}
#+END_SRC

*** 트레이닝킷의 전원을 켜고, 다운로드 및 확인 (Ctrl - U)
#+ATTR_HTML: :width 800 :hight 600
   [[./images/download_and_check.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/led13.jpg]]
   
*** 에러 발생시 확인사항 
    
#+ATTR_HTML: :width 1000 :hight 600
   [[./images/check.jpg]]

** Basic Examples
*** 필 수 함 수 
#+BEGIN_SRC C -n
  /*** 디지털 및 아날로그 관련 함수 ***/
  pinMode(pin, INPUT/OUTPUT);
  digitalRead(pin);
  digitalWrite(pin, HIGH/LOW);
  analogRead(pin);
  analogWrite(pin, 0~255);

  /***** 유용한 함수 ********/
  map(value, 0, 1023, 0, 180);
  delay(ms);
  attachInterrupt(digitalPinToInterrupt(pin), ISR, mode);

  /*** 시리얼 통신 함수******/
  Serial.begin(speed);
  Serial.available();
  Serial.print(val, format);
  Serial.print("Hello World");
  Serial.println(val, format);
  Serial.println("Hello Arduino");
#+END_SRC
   
*** [ LED 점멸 예제 ]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/led.jpg]]

#+BEGIN_SRC C -n
/*********************************************************
                   [ LED 점멸 예제 ]

             첫번째 LED를 ON 시키는 예제
**********************************************************/

//                            1   2   3   4   5   6   7   8                  
const int LED_RED_PIN [8] = {22, 23, 24, 25, 26, 27, 28, 29};

/*************************************************************
 * 함수명 : void setup() 
 * 설  명 : 초기화를 위한 setup 함수, 1번만 실행 된다.
 *************************************************************/
void setup() 
{        
 // for문을 활용하여 LED 1~8까지를 출력으로 설정한다.
  for(int i = 0; i < 8; i++) 
  {
    pinMode(LED_RED_PIN[i], OUTPUT);    // RED  LED 초기화  
    digitalWrite(LED_RED_PIN[i], HIGH);  // RED LED의 LOW 설정   
  }
}

/*************************************************************
 * 함수명 : void loop() 
 * 설  명 : 실질적인 코드가 구동 되는 함수로 무한 반복 됨
 *************************************************************/
void loop() 
{
  // 첫번째 LED(LED_RED_PIN[0])를 ON 시킨다.
  digitalWrite(LED_RED_PIN[0], LOW);
}
#+END_SRC
   
*** 캐릭터 LCD
**** CLCD Module
#+ATTR_HTML: :width 800 :hight 600
   [[./images/clcd_module.jpg]]

**** CLCD Connection
#+ATTR_HTML: :width 800 :hight 600
   [[./images/clcd_connection.jpg]]
**** CLCD Shield
#+ATTR_HTML: :width 800 :hight 600
   [[./images/clcd_shield_zoomin.jpg]]
**** Example 1    
#+BEGIN_SRC C -n
  #include <LiquidCrystal.h>  

  //                RS  EN  DB4 DB5 DB6 DB7 <-- 아두이노와 매칭 되는 LCD의 핀 명칭                  
  LiquidCrystal lcd(41, 39, 45, 44, 43, 42); // LCD의 핀을 설정해준다.

  void setup() {
    pinMode(40, OUTPUT);    //  LCD의 RW핀을 OUTPUT(출력)으로 설정한다.
    digitalWrite(40, LOW);  //  LCD의 RW핀을 LOW로 설정한다.

    lcd.clear();            // LCD 화면에 표시된 것을 모두 지운다
    lcd.begin(16, 2);       // 16x2 LCD . 초기화 한다. 
  }

  void loop() {
    lcd.setCursor(0,0);
    lcd.print("Hello Arduino Mega 2560 ADK!!!!");         // 원하는 메세지를 함수 안에 넣는다. 현재 A가 LCD에 출력 된다.
    delay (10000);
  }
#+END_SRC
     
**** Example Autoscroll    
#+BEGIN_SRC C -n
  #include <LiquidCrystal.h>  

  //                RS   EN  DB4  DB5  DB6  DB7 <-- 아두이노와 매칭 되는 LCD의 핀 명칭                  
  LiquidCrystal lcd(41, 39, 45, 44, 43, 42); // LCD의 핀을 설정해준다.

  void setup() {
    pinMode(40, OUTPUT);    //  LCD의 RW핀을 OUTPUT(출력)으로 설정한다.
    digitalWrite(40, LOW);  //  LCD의 RW핀을 LOW로 설정한다.

    lcd.clear();            // LCD 화면에 표시된 것을 모두 지운다
    lcd.begin(16, 2);       // 16x2 LCD . 초기화 한다. 
  }

  void loop() {
    // set the cursor to (0,0):
    lcd.setCursor(0, 0);
    // print from 0 to 9:
    for (int thisChar = 0; thisChar < 10; thisChar++) {
      lcd.print(thisChar);
      delay(500);
    }

    // set the cursor to (16,1):
    lcd.setCursor(16, 1);
    // set the display to automatically scroll:
    lcd.autoscroll();
    // print from 0 to 9:
    for (int thisChar = 0; thisChar < 10; thisChar++) {
      lcd.print(thisChar);
      delay(500);
    }
    // turn off automatic scrolling
    lcd.noAutoscroll();

    // clear screen for the next loop:
    lcd.clear();
  }
#+END_SRC

**** Example setcursor    
#+BEGIN_SRC C -n
  #include <LiquidCrystal.h>  

  //                RS  EN  DB4 DB5 DB6 DB7 <-- 아두이노와 매칭 되는 LCD의 핀 명칭                  
  LiquidCrystal lcd(41, 39, 45, 44, 43, 42); // LCD의 핀을 설정해준다.

  void setup() {
    pinMode(40, OUTPUT);    //  LCD의 RW핀을 OUTPUT(출력)으로 설정한다.
    digitalWrite(40, LOW);  //  LCD의 RW핀을 LOW로 설정한다.

    lcd.clear();            // LCD 화면에 표시된 것을 모두 지운다
    lcd.begin(16, 2);       // 16x2 LCD . 초기화 한다. 
  }

  void loop() {
    // loop from ASCII 'a' to ASCII 'z':
    for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) {
      // loop over the columns:
      for (int  thisRow = 0; thisRow < numRows; thisRow++) {
        // loop over the rows:
        for (int thisCol = 0; thisCol < numCols; thisCol++) {
          // set the cursor position:
          lcd.setCursor(thisCol, thisRow);
          // print the letter:
          lcd.write(thisLetter);
          delay(200);
        }
      }
    }
  }
#+END_SRC
    
*** 가변저항, CDS
**** Arduino Mega
#+ATTR_HTML: :width 800 :hight 600
   [[./images/arduino_mega_good.jpg]]
**** 가변저항 연결
#+ATTR_HTML: :width 800 :hight 600
   [[./images/variable_resistor.jpg]]
**** ADC 원리 
#+ATTR_HTML: :width 800 :hight 600
   [[./images/adc_theory.jpg]]

**** 가변저항 및 CDS 쉴드 
#+ATTR_HTML: :width 800 :hight 600
   [[./images/variable_resistor_shield.jpg]]

**** 소스코드
#+BEGIN_SRC C -n
// A0 <-> 가변저항
  void setup (){
    Serial.begin (9600);
  }

  void loop (){
    int vrValue = analogRead(A0);
    Serial.println(vrValue);
    analogWrite (13, map ( vrValue, 0, 1023, 0, 255));
    delay (100);
  }

#+END_SRC
*** Servo Motor
    
**** 서보모터 연결
#+ATTR_HTML: :width 800 :hight 600
   [[./images/servo_motor.jpg]]

**** PWM 및 서보모터 각도
#+ATTR_HTML: :width 800 :hight 600
   [[./images/servo_pwm_diagram1.jpg]]
**** 서보모터쉴드 
#+ATTR_HTML: :width 800 :hight 600
   [[./images/motor_shield.jpg]]
**** 모터 드라이버
#+ATTR_HTML: :width 800 :hight 600
   [[./images/motor_driver.jpg]]

**** 예제 소스코드
#+BEGIN_SRC C -n
  #include <Servo.h>
// A0 <-> 가변저항
// 7  <-> 서보모터
  Servo myServo;

  void setup (){
    myServo.attach (7);
    delay (1000);
  }

  void loop (){
    myServo.write ( map( analogRead(A0), 0, 1023, 0, 180));
    delay (100);
  }

#+END_SRC
*** Stepper Motor
**** 1 Phase
#+BEGIN_SRC C -n
/*********************************************************
                   [ 스탭모터 실습 ]
  
                  STEP MOTOR의 1상 제어
**********************************************************/
#define CW  1            // 정방향 값 정의
#define CCW 0            // 역방향 값 정의

const int _A_IN1 = 3;     // Motor Pin A' Input 1 (Orange)
const int  A_IN2 = 2;     // Motor Pin A  Input 2 (Brown)
const int  B_IN3 = 1;     // Motor Pin B  Input 3 (RED)
const int _B_IN4 = 0;     // Motor Pin B' Input 4 (YELLOW)

const int EnablePin = 5;  // 활성핀

// 핀에 인가 될 값에 대한 테이블. 
// 1상 여자, 2상 여자, 1,2상 여자 설정이 가능하다.
// 현재는 1상 여자 설정
const boolean  A_IN_table[4] = {1,0,0,0};
const boolean  B_IN_table[4] = {0,1,0,0};
const boolean _A_IN_table[4] = {0,0,1,0};
const boolean _B_IN_table[4] = {0,0,0,1};

void setup() {
  pinMode(EnablePin,OUTPUT);      // Enable 핀을 출력으로 설정한다
  digitalWrite(EnablePin, HIGH);  // Enable 핀에 HIGH 신호를 준다
  
  pinMode(_A_IN1, OUTPUT); // A 핀을 출력으로 설정
  pinMode(A_IN2, OUTPUT);  // A'핀을 출력으로 설정
  pinMode(_B_IN4, OUTPUT); // B'핀을 출력으로 설정
  pinMode(B_IN3, OUTPUT);  // B 핀을 출력으로 설정
}

void loop() {
  // 스테퍼 모터를 정방향으로 펄스를 준다. (한 바퀴에 200펄스)
  // 100스탭일시 180도만큼 동작한다. 
  stepMotor_move(100, CW, 2200);  // 속도 값은 최소 2200이상 (1상 여자)
  
  // 1000ms 동안 대기 한다.
  delay(1000);
}

/*************************************************************
 * 함수명 : void stepMotor_move(unsigned int MotorStep, 
                 char MotorDirection, unsigned int MotorSpeed)
 * 인자값 : unsigned int MotorStep  - 모터의 스탭 값
            char MotorDirection     - 모터의 동작 방향
            unsigned int MotorSpeed - 모터의 속도
 * 설  명 : 서보모터를 구동 시키는 함수. 1스탭 간격으로 동작한다.
 *************************************************************/
void stepMotor_move(unsigned int MotorStep, char MotorDirection, unsigned int MotorSpeed) {  
  if(MotorDirection) {
    for(int i = 0; i < MotorStep; i++) {
      // 제어를 위한 모터의 핀이 4개 이기 때문에 그 이상의 값으로 loop를 수행해도
      // 정상적인 범주로 값이 들어가야 하기 떄문에  (0,1,2,0,1,2 ... ) %4를 연산한 만큼 반복한다.
      setPhase(i % 4);
      // 'MotorSpeed' microSecod 만큼 신호를 유지한다
      delayMicroseconds(MotorSpeed);  // Pulse Hold Time
    }
  } else {
    for(int j = MotorStep; j >= 0; j--) {
      setPhase(j % 4);
      delayMicroseconds(MotorSpeed);  // Pulse Hold Time
    }
  }
}

/*************************************************************
 * 함수명 : void setPhase(unsigned char phase)
 * 인자값 : unsigned char phase  - 상이 미리 저장 되어 있는 
            배열을 사용하기 위한 인자 값
 * 설  명 : 테이블에 저장 된 상 값으로 펄스를 준다
 *************************************************************/
void setPhase(unsigned char phase) {
  // Pulse generation
  digitalWrite( A_IN2,  A_IN_table[phase]);
  digitalWrite( B_IN3,  B_IN_table[phase]);  
  digitalWrite(_A_IN1, _A_IN_table[phase]);      
  digitalWrite(_B_IN4, _B_IN_table[phase]);   
}
#+END_SRC

**** Using Stepper Motor Library
#+BEGIN_SRC C -n
/*********************************************************
            [ STEP MOTOR 속성을 LCD에 출력하기 ]
  
      STEP MOTOR의 회전 방향을 시리얼 모니터에 출력
**********************************************************/
#include <Stepper.h>

// 시리얼을 사용하기 위해 임시로 핀을 바꿔준다
const int _A_IN1 = 11;        // Motor Pin A' Input 1 (Orange)
const int  A_IN2 = 10;        // Motor Pin A  Input 2 (Brown)
const int  B_IN3 = 9;         // Motor Pin B  Input 3 (RED)
const int _B_IN4 = 8;         // Motor Pin B' Input 4 (YELLOW)
const int ENABLE_PIN = 5;    // 활성핀
const int MOTOR_STEP = 200;  // 360' / 1.8'(모터의 스텝각)

// 스테퍼 클래스의 객체를 생성한다.
Stepper myStepper(MOTOR_STEP, _B_IN4,B_IN3,A_IN2,_A_IN1);   

// 스텝 모터의 속도 값
// 1~100 사이의 값으로 조절하며, 숫자가 높을수록 모터의 속도가 빨라진다.
int speedVal = 100;
// 스텝 모터의 스탭 값
// 50스탭은 90도 이다. (90'/1.8'(모터의 스탭각)) 
int stepVal = 200; // 360'

void setup() {
  // 시리얼 통신을 위해 통신 속도를 9600으로 설정한다.  
  Serial.begin(9600);
  Serial.println("---------------- Start Stepper ----------------");  
  pinMode(ENABLE_PIN,OUTPUT);      // Enable 핀을 출력으로 설정한다
  digitalWrite(ENABLE_PIN, HIGH);  // Enable 핀에 HIGH 신호를 준다
  myStepper.setSpeed(speedVal);    // 스텝 모터의 속도를 설정
}

void loop() {  
  // 매 loop가 반복 될 때 마다 스탭모터의 동작 방향이 바뀐다.
  // 스탭모터를 제어하는 Stepper.step 함수는 인자 값으로 - 값 부터 + 값을 받기 때문에 
  // -1 을 곱함으로써 방향의 변경이 가능하다  
  stepVal = (stepVal*-1);
  
   // 스탭 모터를 움직일 스탭수를 의미하는 변수 stepVal이 0보다 작을 시,
   // 즉 마이너스 값 일시 아래 구문을 동작 시킨다.
  if(stepVal < 0) {
    Serial.println("Stepper Motor Direction : CW ( ClockWise )");
    // step 함수의 인자로 얼마나 움직일지 스텝의 수치를 넣는다. (여기서는 200)    
    // -200 만큼 동작한다.    
    myStepper.step(stepVal);     
  } 
  // 스탭 모터를 움직일 스탭수를 의미하는 변수 stepVal이 0보다 클 시  
  else if(stepVal > 0) {
    Serial.println("Stepper Motor Direction : CCW ( Counter ClockWise )");
    // + 200 만큼 동작한다.    
    myStepper.step(stepVal);     
  }
  delay(1000);
}
#+END_SRC

*** [[target][Interrupt]]
**** 보드별 인터럽트 가능 핀
|-----------------------------------+------------------------------------|
| Board                             | Digital pins usable for interrupts |
|-----------------------------------+------------------------------------|
| /                                 | <                                  |
| Uno, Nano, Mini, other 328-based  | 2, 3                               |
| _Mega, Mega2560, MegaADK_         | 2, 3, 18, 19, 20, 21               |
| Micro, Leonardo, other 32u4-based | 0, 1, 2, 3, 7                      |
| Zero                              | all digital pins, except 4         |
| MKR1000 Rev.1                     | 0, 1, 4, 5, 6, 7, 8, 9, A1, A2     |
| Due                               | all digital pins                   |
| 101                               | all digital pins                   |
|-----------------------------------+------------------------------------|

**** Interrupt Image
#+ATTR_HTML: :width 800 :hight 600
   [[./images/interrupt.jpg]]
**** 예제소스 
#+BEGIN_SRC C -n
  #include <Servo.h>
  // A0 <-> 가변저항
  // 7  <-> 서보모터
  // 2  <-> 딥스위치 
  Servo myServo;
  const byte ledPin = 13;
  const byte interruptPin = 2; // 1. <- 인터럽트핀 정의
  int ledValue = 0;

  // 2. <- 인터럽트 처리를 위한 변수 
  volatile bool ledFlag = false;

  void setup (){
    // 3. <- 인터럽트핀 모드설정
    pinMode(interruptPin, INPUT);
    // 4. <- 인터럽트핀 설정                    핀             ISR         동작시점 
    attachInterrupt(digitalPinToInterrupt(interruptPin), increaseLED, RISING);
    myServo.attach (7);
    delay (1000);
  }

  void loop (){
    myServo.write ( map( analogRead(A0), 0, 1023, 0, 180));
    analogWrite(ledPin, ledValue);
    delay (100);

    if (ledFlag) {
      ledFlag = false;
      if(ledValue == 255) ledValue =0;
      else ledValue++;
    }
  }
  // 5. <- ISR 정의
  void increaseLED() {ledFlag = true;}
#+END_SRC
*** [온,습도 값 출력 ]
**** HT-01SV
#+ATTR_HTML: :width 800 :hight 600
   [[./images/ht_01sv.jpg]]
    
**** Example 1
#+BEGIN_SRC C -n

  #include <SHT1x.h>  // 온습도 센서 라이브러리 다운로드 주소 https://github.com/practicalarduino/SHT1x //

  const int dataPin = 20;          // 데이터핀
  const int clockPin = 21;         // 클럭핀

  SHT1x sht1x(dataPin, clockPin);  // 온습도 센서를 활용을 위해 객체를 선언

  void setup() {
    Serial.begin(9600);  // 시리얼 통신 속도를 9600으로 설정한다.
  }

  void loop() {
    int temperatureValue = (int)sht1x.readTemperatureC() ; // 온도 값을 읽어 저장한다.
    int humidityValue =  (int)sht1x.readHumidity();    // 습도 값을 읽어 저장한다.

    // 온도 값을 출력한다.
    Serial.print("Temperature Value : ");  // 시리얼 모니터에 "Temperature Value"를 출력한다.
    Serial.print(temperatureValue);        // 센서 값을 시리얼 모니터로 출력한다.
    Serial.print("'C");
    
    // 습도 값을 출력한다.
    Serial.print("\t Humidity Value : "); // 시리얼 모니터에 "Humidity Value"를 출력한다.
    Serial.print(humidityValue);          // 센서 값을 시리얼 모니터로 출력한다.  
    Serial.println("%");  
    
    // 약 100ms (1/100초)의 지연시간을 주어 100ms마다 동작을 반복하게 한다.  
    delay(100);          
  }
#+END_SRC
*** Serial Communication
**** UART Block Diagram
#+ATTR_HTML: :width 800 :hight 600
   [[./images/uart_block_diagram.jpg]]
**** UART(universal asynchronous receiver-transmitter) Timing Diagram
#+ATTR_HTML: :width 800 :hight 600
   [[./images/uart_timing_diagram.jpg]]
**** UART Cables
#+ATTR_HTML: :width 800 :hight 600
   [[./images/uart_cable.jpg]]

**** Basic Example
#+BEGIN_SRC C -n
int x = 0;    // variable

void setup() {
  Serial.begin(9600);      // open the serial port at 9600 bps:    
}

void loop() {  
  // print labels 
  Serial.print("NO FORMAT");       // prints a label
  Serial.print("\t");              // prints a tab

  Serial.print("DEC");  
  Serial.print("\t");      

  Serial.print("HEX"); 
  Serial.print("\t");   

  Serial.print("OCT");
  Serial.print("\t");

  Serial.print("BIN");
  Serial.print("\t"); 

  for(x=0; x< 64; x++){    // only part of the ASCII chart, change to suit

    // print it out in many formats:
    Serial.print(x);       // print as an ASCII-encoded decimal - same as "DEC"
    Serial.print("\t");    // prints a tab

    Serial.print(x, DEC);  // print as an ASCII-encoded decimal
    Serial.print("\t");    // prints a tab

    Serial.print(x, HEX);  // print as an ASCII-encoded hexadecimal
    Serial.print("\t");    // prints a tab

    Serial.print(x, OCT);  // print as an ASCII-encoded octal
    Serial.print("\t");    // prints a tab

    Serial.println(x, BIN);  // print as an ASCII-encoded binary
    //                             then adds the carriage return with "println"
    delay(200);            // delay 200 milliseconds
  }
  Serial.println("");      // prints another carriage return
}
#+END_SRC

**** Serial Event
#+BEGIN_SRC C -n

String inputString = "";         
boolean stringComplete = false;  

void setup() {
  Serial.begin(9600);
  inputString.reserve(200);
}

void loop() {
  if (stringComplete) {
    Serial.println(inputString);
    inputString = "";
    stringComplete = false;
  }
}

void serialEvent() {
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    inputString += inChar;
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
}


#+END_SRC
*** Ultrasonic Sensor
**** 초음파 센서 모듈
#+ATTR_HTML: :width 800 :hight 600
   [[./images/ultrasonic.jpg]]

**** 초음파 센서 동작 원리
#+ATTR_HTML: :width 800 :hight 600
   [[./images/ultrasonic_wave.jpg]]
**** 초음파 센서 거리 계산 
#+ATTR_HTML: :width 800 :hight 600
   [[./images/ultrasonic_theory.jpg]]

**** 소 스 코 드
#+BEGIN_SRC C -n 
  /*************************************************************
                  [ Ultra Sonic 센서 실습 ]
    
         시리얼 모니터로 초음파 센서의 값을 확인한다.
  **************************************************************/

  /**************************************************************
   * 초음파 센서 관련 변수 선언
   **************************************************************/ 
  const int  sonicValue = 58;   // 초음파 센서 제어를 위한 값 설정
  const char triggerPin = 2;   // 트리거핀의 번호
  const char echoPin = 3;      // 에코핀의 번호

  int sensorValue = 0;          // 초음파 센서 값을 저장하는 전역 변수

  char buffer[16];                 // 초음파 센서 값을 문자열로 만들기 위한 배열 선언

  /*************************************************************
   * 함수명 : void setup() 
   * 설  명 : 초기화를 위한 setup 함수, 1번만 실행 된다.
   *************************************************************/
  void setup() {

    // 시리얼 통신을 위한 설정, baudrate 9600.
    Serial.begin(9600);
    
    // 트리거 핀은 출력, 에코 핀은 입력으로 설정한다.
    pinMode(triggerPin,OUTPUT);
    pinMode(echoPin,INPUT);
    
    digitalWrite(triggerPin,LOW);
  }

  /*************************************************************
   * 함수명 : void loop() 
   * 설  명 : 실질적인 코드가 구동 되는 함수로 무한 반복 됨
   *************************************************************/
  void loop() {
    sensorValue = getSonic();
    
    Serial.print("Ultra Sonic Value : ");  
    // 받아온 초음파 값을 sprintf로 자릿수를 맞춰 준다.
    sprintf(buffer, "[ %2dcm ]",sensorValue);  
    Serial.println(buffer);
  }
  /***************************************************************
        [ func_ultrasonic ]
      - 초음파 센서와 관련 된 함수 모음
  ****************************************************************/

  /*************************************************************
   * 함수명 : long getSonic() 
   * 반환형 : long
   * 반환값 : duration : 초음파 센서의 값을 반환 받는다.
   * 설  명 : 초음파 센서의 값을 받아온다. 
   *************************************************************/
  long getSonic() {
    long duration, distance;

    // 트리거에 10ms 간격으로 펄스를 준다.
    digitalWrite(triggerPin, HIGH);  
    delayMicroseconds(10);
    digitalWrite(triggerPin, LOW);
      
    // pulsein 함수는 HIGH가 리턴 될 때 까지의 시간을 반환함
    duration = pulseIn(echoPin, HIGH);

    // 왕복거리 이므로  2로 나눈다.
    distance = duration * 0.034 / 2;
      
    // 약 100ms (1/100초)의 지연시간을 주어 100ms마다 동작을 반복하게 한다.
    delay(100);      
      
    // 값이 70 이상을 넘을 시 70을 유지한다.
    if(distance > 500) distance = 500;
      
    return distance;
  }

#+END_SRC
**** pulsein function
#+ATTR_HTML: :width 800 :hight 600
   [[./images/pulseIn.jpg]]
   
*** Bluetooth Communication
**** Bluetooth Module
#+ATTR_HTML: :width 800 :hight 600
   [[./images/bt_module.jpg]]
**** Android App
#+ATTR_HTML: :width 800 :hight 600
   [[./images/spp_pro.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/bluetooth_spp_pro.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/bluetooth_spp_pro1.jpg]]
#+ATTR_HTML: :width 800 :hight 600
   [[./images/bluetooth_spp_pro2.jpg]]
**** Cable Connection
#+BEGIN_SRC C 
BT module      Arduino
BTTXD    <->    RX1(19)
BTRXD    <->    TX1(18)
#+END_SRC
**** Android <-> bluetooth module <-> Arduino <-> Computer Example
#+BEGIN_SRC C -n
/************************************************************
  [ 블루투스 연계 LED 실습 ]
- 안드로이드 기기로 LED를 제어한다.
// 시리얼 데이터 수신에 관한 플래그
 *************************************************************/
boolean ledState = false;
volatile boolean serialEventFlag = false;
volatile boolean serialEventFlag1 = false;

String rxString = "";
String txString = "";

void setup() {
  Serial.begin(9600);
  Serial1.begin(9600);
  pinMode(13, OUTPUT);
  rxString.reserve(200);
  txString.reserve(200);
  Serial.println("---- Starting the Program  -----");
}
void loop() {
  // Event from Android through Bluetooth
  if(serialEventFlag1){
    serialEventFlag1 = false;
    // doesn't work as I intended..Hmmmmm
    Serial.println(rxString.length());
    if(rxString == "off")
      digitalWrite(13, LOW);
    else if(rxString == "on")
      digitalWrite(13, HIGH);
    else if(rxString == "toggle")
      toggleLed();
    Serial.print(rxString);
    rxString = "";
  }
  // Event from PC through RS232
  if(serialEventFlag){
    serialEventFlag = false;
    Serial1.println(txString.length());
    Serial1.print(txString);
    txString = "";
  }
}
void toggleLed(){
  if(ledState){
    ledState = false;
    digitalWrite(13, HIGH);
  } else{
    ledState = true;
    digitalWrite(13, LOW);
  }
}
void serialEvent1() {
  //Bluetooth_RX_Count = 0;
  while(Serial1.available() > 0){
    delay(10);
    char inChar = (char)Serial1.read();
    if(inChar == '\n'){
      serialEventFlag1 = true;
      return;
    }
    rxString += inChar;
  }
}
void serialEvent(){
  while(Serial.available()){
    char inChar = (char)Serial.read();
    txString += inChar;
    if(inChar == '\n')
      serialEventFlag = true;
  }
}
#+END_SRC
** Advanced Examples
*** debounce
#+BEGIN_SRC C -n
// constants won't change. They're used here to
// set pin numbers:
const int Row1 = 22;    // the number of the pushbutton pin
const int Colm1 = 23;    // the number of the pushbutton pin

const int ledPin = 13;      // the number of the LED pin

// Variables will change:
int ledState = HIGH;         // the current state of the output pin
int buttonState;             // the current reading from the input pin
int lastButtonState = LOW;   // the previous reading from the input pin

// the following variables are unsigned long's because the time, measured in miliseconds,
// will quickly become a bigger number than can be stored in an int.
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers

void setup() {
//핀 Row1을 입력으로 설정 
  pinMode(Row1, INPUT);
//핀 Colm1을 출력으로 설정 
  pinMode(Colm1, OUTPUT);
  pinMode(ledPin, OUTPUT);

  // set initial LED state
  digitalWrite(ledPin, ledState);
// Colm1에 로직 0을 인가 
  digitalWrite(Colm1, LOW);
}

void loop() {
  // read the state of the switch into a local variable:
  int reading = digitalRead(Row1);

  // check to see if you just pressed the button
  // (i.e. the input went from LOW to HIGH),  and you've waited
  // long enough since the last press to ignore any noise:

  // If the switch changed, due to noise or pressing:
  if (reading != lastButtonState) {
    // reset the debouncing timer
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    // whatever the reading is at, it's been there for longer
    // than the debounce delay, so take it as the actual current state:

    // if the button state has changed:
    if (reading != buttonState) {
      buttonState = reading;

      // only toggle the LED if the new button state is HIGH
      if (buttonState == HIGH) { // for rising_edge, for falling_edge, use LOW
        ledState = !ledState;
      }
    }
  }

  // set the LED:
  digitalWrite(ledPin, ledState);

  // save the reading.  Next time through the loop,
  // it'll be the lastButtonState:
  lastButtonState = reading;
}


#+END_SRC
   



* org summary
** C-c C-c evaluate the source block
** C-c C-e h h export to HTML
** <s <tab> source block template
** C-c ' edit source code in a seperate buffer in native mode. typing it again after finishing editing will exit the buffer.
** C-c C-l edit the link under cursor

